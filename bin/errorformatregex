#!/usr/bin/env node

const getStdin = require(`get-stdin`)
const fs = require(`fs`)
const path = require(`path`)

process.on(`unhandledRejection`, (reason, p) => {
  console.error(reason)
  process.exit(1)
})

class Errorformatregex {
  constructor() {
    this.locations = []
    // key = filename#row#col
    this.srcLocations = new Set()
    this.lineBreakIndexes = []
    this.argv = {}
  }

  async run() {
    if (this.argv[`--debug`]) {
      this.debug = true
    }

    this.filename = this.argv[`--filename`]

    this.findLineBreakIndexes()
    
    await this.findAllMatches(this.argv[`<regex>`])

    if (this.debug) {
      console.error(`Found locations: ${this.locations.length}`)
      console.error(`Using filename: ${this.filename}`)
    }

    const output = this.addLocationPrefix().join(`\n`)
    process.stdout.write(output)
  }

  parseArgv() {
    return require(`neodoc`).run(
      require(`redent`)(
        `
        ${require(`path`).basename(__filename)} v${
          require(`../package`).version
        }

        ${require(`../package`).description}

        Example regex option: 'e/error.* in file (\\S+) at (\\d+):(\\d+)/igm'

        Uses capture groups to set the filename (1), row (2) and column (3).
        The first character indicates error (e), warning (w), info (i),
        normal (n), delete previously found error location (d),
        find file location by regex (r).
        The last matching regex takes precedence.

        Errorformat needs to be set like this:
        let &errorformat  = 'errorformatregex:%f:%l:%c:%t:%m'

        Usage:
          ${require(`path`).basename(__filename)} [options] <regex>...

        Options:
          -h --help            Show this screen.
          --filename=filename  Provide filename if error format does not provide one.
          --debug              Debug output.
      `
      ),
      {
        optionsFirst: true,
        smartOptions: true,
      }
    )
  }

  async findAllMatches(regexes) {
    
    for (let regex of regexes) {
      const [, errorType = `e`, regexx] = regex.match(/^(\w*)(\/.+)/) || []

      if (!regexx) {
        throw new Error(`No regex found in: ${regex}`)
      }

      let evaledRegex = eval(regexx)
      await this.findMatches(evaledRegex, errorType)
    }
  }

  async findMatches(regex, errorType) {
    // Note: match.index is the same for all capture groups even non capturing (?:)
    let match
    let lastIndex = null
    // regex has to be global - otherwise results in endless loop
    while ((match = regex.exec(this.data)) !== null) {
      if (match.index == lastIndex) {
        throw new Error(`Only regexes with a global flag are supported.`)
      }
      lastIndex = match.index

      const location = { errorType, row: 0, col: 0 }
      const index = match.index

      if (match[0] === ``) {
        throw new Error(`No match for regex: ${regex.source}.`)
      }

      let row = 0
      for (const lineBreak of this.lineBreakIndexes) {
        if (lineBreak > index) {
          break
        }
        row++
      }

      location.errorIndex = index
      location.errorRow = row
      // location.errorCol = TBD

      location.filename = ` `
      if (match[1]) {
        location.filename = match[1]
        // if (!fs.existsSync(location.filename)) {
        //   if (this.debug) {
        //     console.error(
        //       `Skipping entry for missing filename: ${location.filename}.`
        //     )
        //   }
        //   continue
        // }
      }

      if (match[2]) {
        location.row = match[2]
      }

      if (match[3]) {
        location.col = match[3]
      }

      if (errorType === `r`) {
        location.errorType = `e`
        let locationRegex = ``
        if (match[2]) {
          locationRegex = match[2]
        } else {
          locationRegex = match[1]
          location.filename = this.filename
        }
        const otherFile = new Errorformatregex()
        otherFile.argv['<regex>'] = [ `e/${locationRegex}/igm` ]
        otherFile.argv.filename = location.filename
        otherFile.data = fs.readFileSync(location.filename).toString()
        otherFile.findLineBreakIndexes()
        await otherFile.findAllMatches(otherFile.argv[`<regex>`])
        
        for(const otherLocation of otherFile.locations) {
          if(!otherLocation) {
            continue
          }
          
          location.row = otherLocation.errorRow - 1
          // TBD:
          // location.col = 1
          location.errorIndex = otherLocation.errorIndex
          break
        }
      }

      const hash = `${location.filename}#${location.row}#${location.col}`
      // TBD allow dupliates without location?:
      // if (!this.srcLocations.has(hash)) {
      this.locations[row] = location
      // }
      this.srcLocations.add(hash)
    }
  }

  findLineBreakIndexes() {
    const re = /\n/gm
    let match
    while ((match = re.exec(this.data)) !== null) {
      this.lineBreakIndexes.push(match.index)
    }
  }

  addLocationPrefix() {
    const prefixedData = []
    let rowNumber = -1
    for (let rowData of this.data.split(/\n/)) {
      // for testing errorformatregex itself
      rowData = rowData.replace(/^errorformatregex:/, ``)
      // remove potentially existing errorformat regexes.
      rowData = rowData.replace(/^(.+)\:(\d+)\:(\d+)\:/, ``)
      // ?:
      // rowData = rowData.replace(new RegExp(`^` + process.env.PWD + `/*`), ``)
      rowNumber++
      let matched = false
      let prefixed = rowData
      for (const location of this.locations) {
        if (location == null) {
          continue
        }
        if (location.errorRow !== rowNumber) {
          continue
        }
        if (rowData === ``) {
          prefixed = `<errorformatregex: EMPTY ROW MATCH>`
        }
        if (this.filename) {
          location.filename = this.filename
        }
        if (!location.filename) {
          // errorformat does not match if filename is empty
          location.filename = " "
        }
        if (location.errorType === `d`) {
          prefixed = rowData
        } else {
          prefixed = `errorformatregex:${location.filename}:${location.row}:${location.col}:${location.errorType}:${rowData}`
        }
      }
      prefixedData.push(prefixed)
    }

    return prefixedData
  }
}

async function main() {
  const main = new Errorformatregex()
  main.argv = main.parseArgv()
  main.data = await getStdin()
  await main.run()
}

main()
